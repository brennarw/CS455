# CS455_HW1

Debriefing classes from top to bottom:

RoutingCache:
    This class handles caching routes that have already been computed. It stores pre-calculated routes in an array list. The constructor takes in a starting node host name and an ending node host name. With these, it can traverse through the list to see if a route already exists. After a route is calculated in ShortestPath, it is added to the array list in this class. Each messaging node has their own instance of this class in order to keep track of only the routes they have traversed.

ShortestPath:
    This class handles the dijkstra algorithm. I've build an inner TravelNode class in order to build the map using the links in the overlay. The constructor takes in the list of overlay link weights and a RoutingCache object. Within the constructor, it calls 'createTravelNodeObjects' and 'addNeighborsToMap'. Both of these functions handle building the map and each TravelNode object. When 'findShortestPath' is called by the messaging node, it uses the startNode and endNode hostnames to see if the route has already been cached in RoutingCache. If it hasn't, it locates the associated TravelNode objects in the map and calls 'dijkstraPath' to traverse through the map and find the shortest path. This method returns the endNode TravelNode object with all the previousHost and previousWeight attributes in the map updated. Then 'makePathString' is called which traverses back through the path using those two attributes to create a string with all the hostNames and weights of the path. After this path is calculated, it is cached and then returned to the messaging node.

MessagingNode:
    This class handles all functionality for the messaging nodes. When it is called upon, it creates a socket with the registry node and registers itself. It also spawns a TCPServerThread in order to accept connections from other peer nodes, and it spawns a TCPReceiverThread for the registry in order to receive commands. After this, it waits for commands from the registry on what to do. The messaging node is responsible for registering/deregistering itself with the registry node, establishing connections with the specified peer messaging nodes sent from the registry, and finally sending packages over the overlay by using the ShortestPath class to get the shortest route possible. It is also responsible for keeping track of the number/sum of messages sent and received, and the number of messages it relayed and sending these calculations to the registry. In order to do this there are two 'on' methods in this class: onEvent() and onCommandLine(). 'onEvent' handles the events that it receives from the registry or other messaging nodes. 'onCommandLine' handles events that the user gives it through the terminal. 

Registry:
    This class handles all functionality for the registry node. In each overlay, there is only one registry node. When this is started up, it spawns a TCPServerThread in order to listen for connections from messaging nodes. If a connection is accepted, the TCPServerThread spawns a TCPReceiverThread for listening to just that messaging node. After this, it waits for messaging nodes to connect and register themselves. Once they have, the registry node is in charge of setting up the overlay and establishing links, sending out which messaging nodes each messaging node is responsible for connecting to, creating and sending out link weights (which must happen after the overlay is created), issuing the 'TASK-INITIATE' command (which tells the messaging nodes to start relaying messges across the overlay), and finally issuing a 'PULL-TASK-SUMMARY' command in order to validate that all packages were sent and received without being corrupted. In order to do this, this class has two 'on' methods: onEvent() and onCommandLine(). 'onEvent' handles the events it receives from the messaging nodes and 'onCommandLine' handles the events it receives from the user through the terminal. 

Node:
    This is an abstract class the allows the TCPReceiver to handle events for both the registry node and the messaging nodes. Both Registry and MessagingNode extend this class in order to allow for abstraction. It includes the 'onEvent' class that both classes must implement. By using this class, the TCPReceiver can call node.onEvent() and it will go to the correct onEvent method for that node. 

LinkWeightCreator:
    This class handles creaing link weights for the overlay once it is set up. The constructor takes in the socketLinks list that was generated by the Registry, and the hashtable registeredSockets that was also generated by the Registry. With these two lists, it traverses through the socketLinks arraylist and generates a random number link weight for each link, making sure to account for the fact that each link is listed twice, once from each messaging node as the startnode. This class generates an arraylist of strings, each one holding the start and end node of the link as well as the link weight. Each link is only added once to this arraylist, even though the link is bidirectional.

OverlayCreator:
    This class handles creating/setting up the overlay. The constructor takes in the registeredSockets list and the socketLinks list generated by the Registry. With these lists, it traverses through and determines which messaging node is responsible for connecting to which messaging nodes (it is responsible for connecting to the positive port numbers in its socketLinks list). Once it has determined this, it accesses the MessagingNodeInfo object for that peer node and marshalls the data. It does this with each messaging node it is responsible for connecting to, each time appending the marshalled bytes array onto one big array for the messaging node responsible for making all the connections. It then sends this marshalled bytes array to the messaging node responsble for making the connections (at this point the marshalled bytes array holds all the information for each messaging node it needs to connect to). This class doesn't unmarshall the data, this is done in MessagingNodesList.

CommandLineFactory:
    This class handles filtering out which command line was typed into the terminal and return that case to the associated node. If a parameter was given in the command line, this class finds it, stores it, and returns it to the node that called it. 

Deregister:
    This class handles marshalling and unmarshalling the event of a messaging node wanting to deregister. This class is called upon by the messaging node when it wants to deregister. It passes it it's port number and ip address. Then it calls the getBytes() method to marshall the data. Then the messaging node sends these marshalled bytes to the registry where the registry checks if the node can deregister itself.

DeregisterResponse:
    After the registry receives a deregister request from a messaging node, it checks to see if it can deregister that node. If the overlay is still set up or the messaging node was never registered, it sends a status code of 0 back. If neither of these are true, then the node can deregister and it sends a status code of 1 back. Once the registry determines the status code, it creates a DeregisterResponse class with the status code and the response message to the messaging node, saying wether or not the deregistration was successful. It marshalls this data with the getBytes() method in DeregisterResponse and sends it back to that messaging node where it is received and unmarshalled using the second constructor in this class.

Event:
    This abstract class allows for the EventFactory to handle all of the events. Each class in wireformats extends this class and implements a getBytes() method and a getMessageType() method. This abstract class allows me to avoid using generic types and instead casting a wireformats class as an Event object and pass it back to the TCPReceiver where it can send that Event object to the onEvent() methods in both Registry and MessagingNode.

EventFactory:
    This class handles determining which event was send to each TCPReceiverThread. It takes in a marshalled bytes array and from this, grabs the 4 element in order to determine the message type. From the message type, it can determine which Event needs to be handled. Once this is determined, it passes the marshalled bytes array into that class's unmarshalling constructor, casts it as an Event object and returns it to the TCPReceiver. From there, that Event object is send to the correct onEvent() method for the node that the TCPReceiver thread is associated with.

LinkWeights:
    This class handles the event where the Registry sends the overlay link weights to each messaging node. It takes in the arraylist of strings holding all links, it then converts this to one string with the deliminator "|". Then it marshalls the string and returns it back to the registry where it is send to each messaging node. Once received by the TCPReceiver, it is unmarshalled and converted back into an arraylist of strings, each on being a link, and sent to the messaging node.

MessagingNodeInfo:
    This class is a helper class to the MessagingNode class. It stores information for each registered messaging node, including the socket, sender object, ip address, port number, and hostname. There are multiple different constructors depending one what data is accessible at that time. It has a getBytes() method that marshalls the hostname, portnumber, and ipaddress. It has a constructor that unmarshalls this data and it has getter methods for each class variable.

MessgingNodesList:
    This class handles unmarshalling the list of peer nodes each messaging node is responsble for connecting to. It takes in a byte array of marshalled bytes. It then has an unmarshallPeerNodes() method that uses the byte array to first access the messageType and the number of peer nodes. Once it has the number of peernodes, it loops through that number of times and unmarshalls the following data: hostname, portnumber, and ipaddress. With this information it creates a MessagingNodeInfo object and stores it in an arrayList called peerNodesList. After everything is unmarshalled, the messaging node can then access the arraylist of peer nodes in order to see which nodes it is responsible for connecting to and then create a socket for that node. 

PeerNodeCommunication:
    This class handles marshalling and unmarshalling the shortest path strings when messages are being relayed across the overlay. This is called by the messaging nodes after they have determined the next node to receive the message, if they are not supposed to receive the message and instead just relay it. It takes in the dijkstra path and the message/package that is being relayed. It has a getBytes() method to marshall the data and a constructor that unmarshalls the data. 

PeerNodeCommunication:
    This class handles any event where a messaging node just wants to send a string message back to the registry. These cases include when it wants to tell the registry that it has received the link weights, that it has set up all of its connections, or that it has completed its task. It takes in just a string response and has a getBytes() method that marshalls the string and a constructor that unmarshalls the string. 

Register:
    This class handles marshalling and unmarshalling the data for when a MessagingNode wants to register either with the registry or another MessagingNode. It takes in a hostname, portnumber, and ipaddress. It has a getBytes() method to marshall this data and a constructor that unmarshalls this data. It has has getter methods for each class variable. 

RegistryResponse:
    This class handles marshalling and unmarshalling the response from the registry to the messaging node specifying whether or not it's registration was successful. It takes in a status code: 0 meaning the registration failed because the ip addresses don't match, 1 meaning the registration failed becasue the node was already registered, and 2 meaning the registration was successful. It also takes in the number of registered nodes. This class enables the registry to send this response back to each  messaging node after they send a registration request. It has a getBytes() method to marshall this data and a constructor to unmarshall the data, as well as getter methods for each class variable.

TaskInitate:   
    This class handles marshalling and unmarshalling the TASK-INITATE command from the registry that needs to be sent to each messaging node. It takes in the number of rounds and the predefined message: "TASK-INITIATE". It has a getBytes() method to marshall this data and a constructor that unmarshalls the data, as well as class variables for each class variable.

TaskSummaryResonse:
    This class handles marshalling and unmarshalling the data that needs to be sent from each messaging node to the registry after the "PULL-TRAFFIC-SUMMARY" task is issued to each messaging node. This data includes the number and summation of messages sent, the number and summation of messages received, and the number of messages relayed. Additionally, this class takes in a hostname, ip address, and port number in order for the registry to determine who this data is coming from and what messaging node it is associated with. It has a getBytes() method to marshall this data and a constructor to unmarshall this data, as well as getter methods for each class variable. 





